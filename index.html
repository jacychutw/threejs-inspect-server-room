<!DOCTYPE html>
<html lang="zh-Hant">

<head>
  <meta charset="UTF-8" />
  <title>Server Room — Button Look + Click-to-Tag（含碰撞）</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
    }

    /* HUD 最上層 */
    .hud {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 3;
    }

    .pad {
      position: absolute;
      bottom: 24px;
      left: 24px;
      pointer-events: auto;
      user-select: none;
      display: grid;
      grid-template-columns: 56px 56px 56px;
      grid-template-rows: 56px 56px 56px;
      gap: 8px;
    }

    .pad .btn {
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      touch-action: none;
      background: rgba(0, 0, 0, .45);
      color: #fff;
      font: 600 16px/1 system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans TC";
      border: 1px solid rgba(255, 255, 255, .2);
      border-radius: 12px;
      backdrop-filter: blur(4px);
      transition: transform .06s ease;
    }

    .pad .btn:active,
    .pad .btn.active {
      transform: scale(.95);
      background: rgba(0, 0, 0, .6);
    }

    .look-pad {
      position: absolute;
      right: 24px;
      bottom: 24px;
      pointer-events: auto;
      display: grid;
      grid-template-columns: 56px;
      grid-template-rows: 56px 56px;
      gap: 8px;
    }

    .hint {
      position: absolute;
      left: 24px;
      bottom: 210px;
      pointer-events: none;
      color: #fff;
      background: rgba(0, 0, 0, .45);
      padding: 8px 10px;
      border-radius: 8px;
      font: 500 13px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans TC";
    }

    /* CSS2D 標籤可點 */
    .label {
      pointer-events: auto;
    }
  </style>
</head>

<body>
  <!-- ===== HUD ===== -->
  <div class="hud">
    <div class="pad" aria-label="Move/Rotate Pad">
      <div></div><button id="btnForward" class="btn" title="前進 (W/↑)">▲</button>
      <div></div>
      <button id="btnRotateLeft" class="btn" title="左轉 (A/←)">◀</button>
      <div></div>
      <button id="btnRotateRight" class="btn" title="右轉 (D/→)">▶</button>
      <div></div>
      <button id="btnBackward" class="btn" title="後退 (S/↓)">▼</button>
      <div></div>
    </div>
    <div class="look-pad" aria-label="Look Up/Down Pad">
      <button id="btnLookUp" class="btn" title="抬頭 (Q)">Look ↑</button>
      <button id="btnLookDown" class="btn" title="低頭 (E)">Look ↓</button>
    </div>
    <div class="hint">單擊畫面：新增標註。使用下方按鈕移動/轉向/抬頭低頭。已加入：撞到柱子/機櫃就會停。</div>
  </div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.164.1';
    import { GLTFLoader } from 'https://esm.sh/three@0.164.1/examples/jsm/loaders/GLTFLoader.js';
    import { CSS2DRenderer, CSS2DObject } from 'https://esm.sh/three@0.164.1/examples/jsm/renderers/CSS2DRenderer.js';

    // ===== 場景基礎 =====
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xeeeeee);

    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
    camera.rotation.order = 'YXZ';

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.toneMapping = THREE.ACESFilmicToneMapping; // 調整亮度跟色調
    renderer.toneMappingExposure = 1.4;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    // CSS2D 層（可點）
    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(innerWidth, innerHeight);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.inset = '0';
    labelRenderer.domElement.style.pointerEvents = 'auto';
    labelRenderer.domElement.style.zIndex = '2';
    document.body.appendChild(labelRenderer.domElement);

    // ===== 燈光 =====
    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.5));
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const dir = new THREE.DirectionalLight(0xffffff, 2.5);
    dir.position.set(20, 10, 10);
    scene.add(dir);

    // ===== 全域狀態 / 常數 =====
    const mouseNDC = new THREE.Vector2();  // 標準化裝置座標
    const pickables = []; // 可被點擊選取的物件清單
    const tags = []; // 放標記（label）的資料結構方便操作

    // ====== 碰撞檢查（柱子 / server 不穿透）======
    const colliders = [];                 // 會被視為障礙物的 mesh
    const PLAYER_RADIUS = 0.30;           // 相機碰撞半徑（可調 0.25~0.4）
    const RAY_OFFSETS_Y = [0, -0.6, -1.2];// 眼睛、腰、膝 三條射線，提升穩定性

    // ===== Raycaster（點擊放標記）=====
    const raycaster = new THREE.Raycaster();

    // 專門做遮擋檢查（不要和點擊共用，避免干擾）
    const occRay = new THREE.Raycaster();
    const OCC_EPS = 0.04; // 稍微調大，減少貼面誤判

    // ===== 標註：可見性同步 =====
    function syncTagVisibility(t) {
      // 只要被遮擋，就全部隱藏；沒遮擋時：開卡片→只顯示卡片；關卡片→只顯示圓點
      t.dotObj.visible = !t.occluded && !t.open;
      t.cardObj.visible = !t.occluded && t.open;
    }

    // ===== 標註：遮擋檢查 =====
    function updateTagOcclusion() {
      if (!colliders.length || !tags.length) return;

      for (const t of tags) {
        // 讀世界座標；保險起見先刷新矩陣
        t.dotObj.updateWorldMatrix(true, false);
        const worldPos = new THREE.Vector3();
        t.dotObj.getWorldPosition(worldPos);

        const dir = worldPos.clone().sub(camera.position);
        const dist = dir.length();
        if (dist < 1e-4) {
          t.occluded = false;
          syncTagVisibility(t);
          continue;
        }
        dir.normalize();

        occRay.set(camera.position, dir);
        occRay.near = 0.001;
        occRay.far = Math.max(0, dist - OCC_EPS);

        const hits = occRay.intersectObjects(colliders, true);
        t.occluded = hits.length > 0;

        syncTagVisibility(t);
      }
    }

    // ===== 建立可點標籤 + 內容卡片（用 cardObj.visible 控制顯示）=====
    function addTag(worldPos, title = '標註', html = '') {
      // Tag 圓點
      const dot = document.createElement('button');
      dot.className = 'label tag-dot';
      dot.title = '查看標註';
      dot.textContent = 'i';
      dot.style.cssText =
        'width:22px;height:22px;border-radius:50%;' +
        'border:2px solid #fff;background:rgba(40,120,255,.95);color:#fff;' +
        'font:700 12px/1 system-ui;display:flex;align-items:center;justify-content:center;' +
        'box-shadow:0 2px 8px rgba(0,0,0,.35);cursor:pointer;';
      dot.style.zIndex = '1'; // 圓點放低一點
      const dotObj = new CSS2DObject(dot);
      dotObj.position.copy(worldPos);
      scene.add(dotObj);

      // 內容卡片
      const card = document.createElement('div');
      card.className = 'label';
      card.style.cssText =
        'min-width:220px;max-width:320px;padding:10px 12px;' +
        'background:rgba(0,0,0,.72);color:#fff;border-radius:10px;' +
        'font:500 13px/1.45 system-ui;backdrop-filter:blur(4px);' +
        'box-shadow:0 10px 24px rgba(0,0,0,.35);';
      card.style.zIndex = '10'; // 卡片永遠在圓點之上
      card.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">
          <strong>${title}</strong>
          <span style="display:flex;gap:6px;">
            <button class="editBtn"   style="all:unset;cursor:pointer;padding:4px 6px;border-radius:6px;background:rgba(255,255,255,.15)">編輯</button>
            <button class="deleteBtn" style="all:unset;cursor:pointer;padding:4px 6px;border-radius:6px;background:rgba(255,80,80,.25)">刪除</button>
            <button class="closeBtn"  style="all:unset;cursor:pointer;padding:4px 6px;border-radius:6px;background:rgba(255,255,255,.15)">關閉</button>
          </span>
        </div>
        <div class="body" style="margin-top:6px">${html}</div>
        `;
      const cardObj = new CSS2DObject(card);
      // 稍微再往上偏一點，避免重疊
      cardObj.position.copy(worldPos).add(new THREE.Vector3(0, 0.3, 0));
      cardObj.visible = false;
      scene.add(cardObj);

      // 小工具：統一控制開/關（只改狀態，實際顯示交給 syncTagVisibility）
      const rec = { dotObj, cardObj, open: false, occluded: false };

      const setOpen = (open) => {
        rec.open = open;
        syncTagVisibility(rec);
      };

      // ---- 行為 ----
      const removeTag = () => {
        scene.remove(dotObj); scene.remove(cardObj);
        dot.remove(); card.remove();
      };

      dot.addEventListener('click', (ev) => { ev.stopPropagation(); setOpen(!rec.open); });
      card.querySelector('.closeBtn')?.addEventListener('click', (ev) => { ev.stopPropagation(); setOpen(false); });
      card.querySelector('.editBtn')?.addEventListener('click', (ev) => {
        ev.stopPropagation();
        const body = card.querySelector('.body');
        const v = prompt('編輯標註內容：', body ? body.innerText : '');
        if (v != null) body.innerHTML = String(v).replace(/\n/g, '<br/>');
      });
      card.querySelector('.deleteBtn')?.addEventListener('click', (ev) => { ev.stopPropagation(); removeTag(); });

      // ⬇️ 重要：把「style.visibility = hidden/visible」那種 DOM 操作移除，交給 syncTagVisibility
      tags.push(rec);
      syncTagVisibility(rec);   // 初始狀態：只顯示圓點
      return rec;
    }

    // ===== 收合所有標註卡片 =====
    function closeAllTags() {
      let closed = false;
      for (const t of tags) {
        if (t.open) {
          t.open = false;
          syncTagVisibility(t);
          closed = true;
        }
      }
      return closed;
    }

    // ===== 載入 GLB =====
    const loader = new GLTFLoader();
    let moveBounds = null;
    loader.load('models/server_room.glb', (gltf) => {
      const model = gltf.scene;

      // 置中
      const box = new THREE.Box3().setFromObject(model);
      const center = new THREE.Vector3(); box.getCenter(center);
      model.position.sub(center);
      scene.add(model);

      // === 算地板高度並把視角設為 1.6 公尺 ===
      const size = new THREE.Vector3();
      box.getSize(size);
      const floorY = -size.y / 2;   // 置中後，地板大約在 -size.y/2
      const EYE_HEIGHT = 1.6;       // 160公分
      camera.position.set(0, floorY + EYE_HEIGHT, -1.5);

      // 收集 Mesh 當 pickables + colliders（障礙）
      model.traverse(o => {
        if (o.isMesh) {
          pickables.push(o);      // 用來打點新增標註
          colliders.push(o);      // 當作障礙物以避免穿透
          o.updateMatrixWorld(true);
        }
      });

      // === 建立可移動方形邊界（縮小一點 margin，避免穿牆）===
      const margin = 0.3; // 你可調整 0.2~0.5
      const minX = -size.x / 2 + margin;
      const maxX = size.x / 2 - margin;
      const minZ = -size.z / 2 + margin;
      const maxZ = size.z / 2 - margin;
      moveBounds = new THREE.Box2(
        new THREE.Vector2(minX, minZ),
        new THREE.Vector2(maxX, maxZ)
      );

    }, undefined, (e) => console.error('❌ GLB 載入失敗：', e));

    // ===== 只有按鈕/鍵盤控制：移動/旋轉/抬頭低頭 =====
    let moveForward = false, moveBackward = false, rotateLeft = false, rotateRight = false, lookUp = false, lookDown = false;
    let velocity = new THREE.Vector3();
    const speed = 2.0, rotationSpeed = 1.5, lookSpeed = 1.0;
    let moveStartTime = 0, moveInProgress = false;

    document.addEventListener('keydown', (e) => {
      if (!moveInProgress) {
        switch (e.code) {
          case 'ArrowUp': case 'KeyW': moveForward = true; break;
          case 'ArrowDown': case 'KeyS': moveBackward = true; break;
          case 'ArrowLeft': case 'KeyA': rotateLeft = true; break;
          case 'ArrowRight': case 'KeyD': rotateRight = true; break;
          case 'KeyQ': lookUp = true; break;
          case 'KeyE': lookDown = true; break;
        }
        moveStartTime = performance.now();
        moveInProgress = true;
      }
    });
    document.addEventListener('keyup', (e) => {
      switch (e.code) {
        case 'ArrowUp': case 'KeyW': moveForward = false; break;
        case 'ArrowDown': case 'KeyS': moveBackward = false; break;
        case 'ArrowLeft': case 'KeyA': rotateLeft = false; break;
        case 'ArrowRight': case 'KeyD': rotateRight = false; break;
        case 'KeyQ': lookUp = false; break;
        case 'KeyE': lookDown = false; break;
      }
    });

    function bindHoldButton(id, onDown, onUp) {
      const el = document.getElementById(id);
      const activate = (e) => { e.preventDefault(); el.classList.add('active'); onDown(); };
      const deactivate = (e) => { e && e.preventDefault(); el.classList.remove('active'); onUp(); };
      el.addEventListener('mousedown', activate); addEventListener('mouseup', deactivate);
      el.addEventListener('touchstart', activate, { passive: false });
      addEventListener('touchend', deactivate, { passive: false });
      addEventListener('touchcancel', deactivate, { passive: false });
      el.addEventListener('mouseleave', (e) => { if (e.buttons === 1) deactivate(e); });
    }
    bindHoldButton('btnForward', () => { moveForward = true; moveStartTime = performance.now(); moveInProgress = true; }, () => { moveForward = false; moveInProgress = false; });
    bindHoldButton('btnBackward', () => { moveBackward = true; moveStartTime = performance.now(); moveInProgress = true; }, () => { moveBackward = false; moveInProgress = false; });
    bindHoldButton('btnRotateLeft', () => { rotateLeft = true; moveStartTime = performance.now(); moveInProgress = true; }, () => { rotateLeft = false; moveInProgress = false; });
    bindHoldButton('btnRotateRight', () => { rotateRight = true; moveStartTime = performance.now(); moveInProgress = true; }, () => { rotateRight = false; moveInProgress = false; });
    bindHoldButton('btnLookUp', () => { lookUp = true; moveStartTime = performance.now(); moveInProgress = true; }, () => { lookUp = false; moveInProgress = false; });
    bindHoldButton('btnLookDown', () => { lookDown = true; moveStartTime = performance.now(); moveInProgress = true; }, () => { lookDown = false; moveInProgress = false; });

    let last = performance.now();

    // ===== 碰撞判斷：本幀位移是否會撞到障礙 =====
    function willCollide(origin, moveVec) {
      const len = moveVec.length();
      if (len < 1e-6) return false;
      const dir = moveVec.clone().normalize();

      for (const offY of RAY_OFFSETS_Y) {
        const from = new THREE.Vector3(origin.x, origin.y + offY, origin.z);
        const ray = new THREE.Raycaster(from, dir, 0, len + PLAYER_RADIUS);
        const hits = ray.intersectObjects(colliders, true);
        if (hits.length && hits[0].distance <= len + PLAYER_RADIUS) {
          return true; // 撞到了
        }
      }
      return false;
    }

    function updateMovement() {
      const now = performance.now();
      const dt = Math.min((now - last) / 1000, 0.1); // 計算兩幀時間差，限制最大0.1秒 避免卡頓
      last = now;

      velocity.set(0, 0, 0); // 每次更新都先歸零速度

      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion); // 原指向世界座標的 -Z 軸 改轉成世界座標的前方向
      forward.y = 0; forward.normalize(); // 移除垂直分量，保證平地移動
      const backward = forward.clone().negate();

      const elapsed = (now - moveStartTime) / 1000;
      if (elapsed <= 2) {
        if (moveForward) velocity.addScaledVector(forward, speed * dt);
        if (moveBackward) velocity.addScaledVector(backward, speed * dt);
      } else {
        moveInProgress = false;
      }

      // 嘗試移動前先做碰撞檢查（撞到就不移動）
      if (!willCollide(camera.position, velocity)) {
        camera.position.add(velocity);
      }

      // === 仍保留方形範圍限制（限制X/Z不能超過範圍，避免走出模型外）===
      if (moveBounds) {
        camera.position.x = Math.min(moveBounds.max.x, Math.max(moveBounds.min.x, camera.position.x));
        camera.position.z = Math.min(moveBounds.max.y, Math.max(moveBounds.min.y, camera.position.z));
      }

      if (rotateLeft) camera.rotation.y += rotationSpeed * dt;
      if (rotateRight) camera.rotation.y -= rotationSpeed * dt;

      if (lookUp) { camera.rotation.x += lookSpeed * dt; if (camera.rotation.x > Math.PI / 2) camera.rotation.x = Math.PI / 2; }
      if (lookDown) { camera.rotation.x -= lookSpeed * dt; if (camera.rotation.x < -Math.PI / 2) camera.rotation.x = -Math.PI / 2; }
      camera.rotation.z = 0; // 不傾斜
    }

    // ===== 點擊畫面：新增標註 =====
    document.addEventListener('click', (e) => {
      const inLabel = !!e.target.closest('.label'); // 點在標籤或卡片上
      const inHUD = !!e.target.closest('.hud');   // 點在 HUD 上

      // 不是點在標籤上：先嘗試收起所有卡片
      if (!inLabel) {
        const didClose = closeAllTags();
        if (didClose) return; // ← 這次點擊只做「收起」，不要新增標註
      }

      // 點在 HUD 或標籤上就不新增標註
      if (inHUD || inLabel) return;

      // 以下才是「新增標註」
      const rect = renderer.domElement.getBoundingClientRect();
      mouseNDC.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouseNDC.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouseNDC, camera);
      const hits = raycaster.intersectObjects(pickables, true); // 檢查這條射線是否擊中任何可標註的物件
      if (!hits.length) return;

      const hit = hits[0]; // 擊中的世界座標
      const pos = hit.point.clone().add(hit.face?.normal?.clone().multiplyScalar(0.02) || new THREE.Vector3());

      const text = prompt('輸入標註內容：', '這裡是我的標註');
      if (text === null) return; // 取消就不新增
      const content = (text.trim() === '' ? '（未命名標註）' : text).replace(/\n/g, '<br/>');
      addTag(pos, '標註', content);
    });

    // ===== 視窗縮放 =====
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;  // 更新相機長寬比
      camera.updateProjectionMatrix();  // 重新計算投影矩陣
      renderer.setSize(innerWidth, innerHeight); // WebGLRenderer 跟著縮放
      labelRenderer.setSize(innerWidth, innerHeight); // CSS2DRenderer 跟著縮放
    });

    // ===== 迴圈 =====
    function animate() {
      requestAnimationFrame(animate); // 註冊下一幀（由瀏覽器排程）
      updateMovement(); // 處理輸入、移動、碰撞、邊界
      updateTagOcclusion(); // 處理標籤遮擋（可見性切換）
      renderer.render(scene, camera); // 繪製 3D
      labelRenderer.render(scene, camera); // 繪製 2D 標籤（覆蓋在上層）
    }
    animate();
  </script>

</body>

</html>